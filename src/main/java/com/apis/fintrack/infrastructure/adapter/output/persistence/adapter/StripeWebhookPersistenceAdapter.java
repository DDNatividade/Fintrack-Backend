package com.apis.fintrack.infrastructure.adapter.output.persistence.adapter;

import com.apis.fintrack.domain.payment.port.output.WebhooksPersistencePort;
import com.apis.fintrack.infrastructure.adapter.output.persistence.entity.StripeWebhookJPAEntity;
import com.apis.fintrack.infrastructure.adapter.output.persistence.model.WebhookEventStatus;
import com.apis.fintrack.infrastructure.adapter.output.persistence.repository.StripeWebhookEventRepository;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.Optional;

/**
 * Infrastructure adapter that implements WebhooksPersistencePort using JPA repository.
 * It encapsulates all database logic related to persisting and updating webhook events.
 */
@Component
public class StripeWebhookPersistenceAdapter implements WebhooksPersistencePort {

    private static final Logger log = LoggerFactory.getLogger(StripeWebhookPersistenceAdapter.class);

    private final StripeWebhookEventRepository repository;

    private final Counter dbPersistedCounter;
    private final Counter dbRaceCounter;
    private final Counter dbFailureCounter;

    public StripeWebhookPersistenceAdapter(StripeWebhookEventRepository repository, MeterRegistry meterRegistry) {
        this.repository = repository;
        this.dbPersistedCounter = meterRegistry.counter("webhook.db.persisted.total");
        this.dbRaceCounter = meterRegistry.counter("webhook.db.race.total");
        this.dbFailureCounter = meterRegistry.counter("webhook.db.failure.total");
    }

    @Override
    public boolean existsByEventId(String eventId) {
        try {
            return repository.existsByEventId(eventId);
        } catch (Exception e) {
            log.error("Error checking webhook event existence id={}", eventId, e);
            dbFailureCounter.increment();
            throw e;
        }
    }

    @Override
    @Transactional
    public void saveReceivedEvent(String eventId, String eventType, String payload) {
        try {
            // Use the JPA entity; id will be null and generated by the DB
            StripeWebhookJPAEntity entity = new StripeWebhookJPAEntity(null, eventId, eventType, payload, WebhookEventStatus.RECEIVED, Instant.now());
            repository.save(entity);
            dbPersistedCounter.increment();
            log.info("Persisted webhook event to DB id={}, type={}", eventId, eventType);
        } catch (DataIntegrityViolationException dive) {
            // Race condition: another process inserted the same event concurrently
            log.info("Race inserting webhook event id={}, another process likely inserted it", eventId);
            dbRaceCounter.increment();
        } catch (Exception e) {
            log.error("Failed to persist received webhook event id={}", eventId, e);
            dbFailureCounter.increment();
            throw e;
        }
    }

    @Override
    @Transactional
    public void markProcessed(String eventId) {
        try {
            Optional<StripeWebhookJPAEntity> optional = repository.findByEventId(eventId);
            if (optional.isPresent()) {
                StripeWebhookJPAEntity e = optional.get();
                e.setStatus(WebhookEventStatus.PROCESSED);
                repository.save(e);
                log.info("Marked webhook event as PROCESSED id={}", eventId);
            } else {
                log.warn("Trying to mark processed an event that does not exist id={}", eventId);
            }
        } catch (Exception e) {
            log.error("Failed to mark webhook event as processed id={}", eventId, e);
            dbFailureCounter.increment();
            throw e;
        }
    }
}
